from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import sqlite3
import os

app = FastAPI(title="PatternOS API")

# Get absolute database path
DB_PATH = os.path.join(os.getcwd(), "intent_intelligence.db")

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=False,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
async def root():
    return {"service": "PatternOS API", "status": "operational", "db_exists": os.path.exists(DB_PATH)}

@app.get("/health")
async def health():
    return {"status": "healthy", "db": os.path.exists(DB_PATH)}

@app.get("/api/master/dashboard-v2")
async def master_dashboard_v2(clientId: str = "zepto"):
    try:
        conn = sqlite3.connect(DB_PATH, timeout=10)
        cursor = conn.cursor()
        
        cursor.execute("SELECT COALESCE(SUM(total_amount), 0) FROM purchases WHERE attributed_to_ad = 1")
        total_gmv = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(DISTINCT user_id) FROM user_events")
        users_tracked = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(DISTINCT user_id) FROM intent_scores WHERE intent_score >= 0.7")
        high_intent_users = cursor.fetchone()[0]
        
        conn.close()
        
        return {
            "total_gmv": round(total_gmv, 2),
            "attributed_revenue": round(total_gmv * 0.7, 2),
            "users_tracked": users_tracked,
            "high_intent_users": high_intent_users,
            "platform_revenue": round(total_gmv * 0.7 * 0.07, 2)
        }
    except Exception as e:
        return {"error": str(e), "total_gmv": 0}

@app.get("/api/master/intent-stats")
async def intent_stats():
    try:
        import sqlite3
        conn = sqlite3.connect("intent_intelligence.db")
        cursor = conn.cursor()
        
        cursor.execute("SELECT COUNT(DISTINCT user_id) FROM intent_scores")
        total = cursor.fetchone()[0]
        
        cursor.execute("SELECT intent_level, COUNT(*) FROM intent_scores GROUP BY intent_level")
        results = cursor.fetchall()
        
        dist = {"high": 0, "medium": 0, "low": 0}
        for level, count in results:
            if level:
                dist[level.lower()] = count
        
        conn.close()
        return {"totalUsers": total, "intentDistribution": dist}
    except:
        return {"totalUsers": 0, "intentDistribution": {"high": 0, "medium": 0, "low": 0}}

@app.get("/api/master/platform-revenue")

@app.get("/api/master/platform-revenue")
async def platform_revenue(period: str = "monthly"):
    try:
        import sqlite3
        conn = sqlite3.connect("patternos_campaign_data.db")
        cursor = conn.cursor()
        
        cursor.execute("SELECT SUM(attributed_spend) FROM ad_attribution")
        total_attributed = cursor.fetchone()[0] or 0
        
        # Get max date and calculate period
        cursor.execute("SELECT MAX(date) FROM ad_spend_daily")
        max_date = cursor.fetchone()[0]
        
        if period == "monthly":
            days = 30
        elif period == "quarterly":
            days = 90
        elif period == "half-yearly":
            days = 180
        else:
            days = 365
        
        cursor.execute("SELECT SUM(spend_value) FROM ad_spend_daily WHERE intent_level='High' AND date >= date(?, '-' || ? || ' days')", (max_date, days))
        high_intent_spend = cursor.fetchone()[0] or 0
        
        cursor.execute("SELECT SUM(spend_value) FROM ad_spend_daily WHERE intent_level IN ('Medium', 'Low') AND date >= date(?, '-' || ? || ' days')", (max_date, days))
        other_spend = cursor.fetchone()[0] or 0
        
        conn.close()
        
        if period == "monthly":
            retainer = 300000
        elif period == "quarterly":
            retainer = 900000
        elif period == "half-yearly":
            retainer = 1800000
        else:
            retainer = 3600000
        
        high_commission = high_intent_spend * 0.20
        other_commission = other_spend * 0.10
        total_revenue = retainer + high_commission + other_commission
        
        return {
            "monthly_retainer": retainer,
            "total_ad_spend": high_intent_spend + other_spend,
            "high_intent_campaign_spend": high_intent_spend,
            "high_intent_premium": round(high_commission, 2),
            "other_ad_spend": other_spend,
            "other_commission": round(other_commission, 2),
            "ad_commission": round(other_commission, 2),
            "attributed_revenue": round(total_attributed, 2),
            "total": round(total_revenue, 2),
            "total_revenue": round(total_revenue, 2)
        }
    except Exception as e:
        return {"error": str(e), "total_revenue": 0}

@app.get("/api/master/revenue-opportunities")
async def revenue_opportunities(minScore: float = 0.7):
    try:
        import sqlite3
        conn = sqlite3.connect("intent_intelligence.db")
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT 
                category,
                COUNT(DISTINCT user_id) as users,
                AVG(intent_score) as avg_intent_score,
                SUM(CASE WHEN intent_level='High' THEN 1 ELSE 0 END) as high_intent_users
            FROM intent_scores
            WHERE intent_score >= ?
            GROUP BY category
            ORDER BY high_intent_users DESC
        """, (minScore,))
        
        opportunities = []
        for row in cursor.fetchall():
            opp = dict(row)
            opp['potential_revenue'] = opp['high_intent_users'] * 2500
            opportunities.append(opp)
        
        conn.close()
        return {"opportunities": opportunities}
    except Exception as e:
        return {"opportunities": [], "error": str(e)}

@app.get("/api/master/brand-performance-v2")
async def brand_performance(period: str = "monthly"):
    try:
        import sqlite3
        conn = sqlite3.connect("patternos_campaign_data.db")
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        # Get max date for period filtering
        cursor.execute("SELECT MAX(date) FROM ad_spend_daily")
        max_date = cursor.fetchone()[0]
        
        if period == "monthly":
            days = 30
        elif period == "quarterly":
            days = 90
        elif period == "half-yearly":
            days = 180
        else:
            days = 365
        
        # Get brand performance with SKU prices
        cursor.execute("""
            SELECT 
                a.brand,
                SUM(a.spend_value) as ad_spend,
                SUM(a.conversions * COALESCE(s.selling_price, 500)) as revenue,
                SUM(a.conversions) as purchases,
                SUM(a.clicks) as clicks,
                SUM(a.impressions) as impressions
            FROM ad_spend_daily a
            LEFT JOIN sku_library s ON a.sku_id = s.sku_id
            WHERE a.date >= date(?, '-' || ? || ' days')
            GROUP BY a.brand
            ORDER BY ad_spend DESC
            LIMIT 5
        """, (max_date, days))
        
        brands = []
        for row in cursor.fetchall():
            b = dict(row)
            # Calculate actual ROAS from revenue and ad spend
            b['roas'] = round(b['revenue'] / b['ad_spend'], 2) if b['ad_spend'] > 0 else 0
            b['ctr'] = round((b['clicks'] / b['impressions'] * 100), 2) if b['impressions'] > 0 else 0
            b['conv_rate'] = round((b['purchases'] / b['clicks'] * 100), 2) if b['clicks'] > 0 else 0
            brands.append(b)
        
        conn.close()
        return {"brands": brands}
    except Exception as e:
        return {"brands": [], "error": str(e)}

# Intent Dashboard API
@app.get("/api/v1/intent/stats")
async def intent_stats_v1(clientId: str = "zepto"):
    try:
        import sqlite3
        conn = sqlite3.connect("intent_intelligence.db")
        cursor = conn.cursor()
        
        # Total users tracked
        cursor.execute("SELECT COUNT(DISTINCT user_id) FROM intent_scores")
        total_users = cursor.fetchone()[0]
        
        # Total events
        cursor.execute("SELECT COUNT(*) FROM user_events")
        total_events = cursor.fetchone()[0]
        
        # Total scores
        cursor.execute("SELECT COUNT(*) FROM intent_scores")
        total_scores = cursor.fetchone()[0]
        
        # Intent distribution
        cursor.execute("SELECT intent_level, COUNT(*) FROM intent_scores GROUP BY intent_level")
        results = cursor.fetchall()
        
        distribution = {"high": 0, "medium": 0, "low": 0}
        for level, count in results:
            if level:
                distribution[level.lower()] = count
        
        conn.close()
        
        return {
            "totalUsers": total_users,
            "totalEvents": total_events,
            "totalScores": total_scores,
            "intentDistribution": distribution
        }
    except Exception as e:
        return {
            "totalUsers": 0,
            "totalEvents": 0,
            "totalScores": 0,
            "intentDistribution": {"high": 0, "medium": 0, "low": 0},
            "error": str(e)
        }

# Enhanced Intent Dashboard - Phase 1: Behavioral Intelligence
@app.get("/api/v1/intent/behavioral-deep-dive")
async def behavioral_deep_dive(clientId: str = "zepto"):
    try:
        import sqlite3
        conn = sqlite3.connect("intent_intelligence.db")
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        # Search Patterns
        cursor.execute("""
            SELECT category, COUNT(*) as search_count, AVG(intent_score) as avg_intent
            FROM intent_scores
            WHERE search_queries > 0
            GROUP BY category
            ORDER BY search_count DESC
            LIMIT 10
        """)
        top_searches = [dict(row) for row in cursor.fetchall()]
        
        # Purchase History Patterns
        cursor.execute("""
            SELECT 
                COUNT(DISTINCT user_id) as total_users,
                AVG(page_views) as avg_page_views,
                AVG(time_spent) as avg_time_spent,
                AVG(cart_additions) as avg_cart_adds
            FROM intent_scores
        """)
        behavior_stats = dict(cursor.fetchone())
        
        # Intent Signals by Category
        cursor.execute("""
            SELECT 
                category,
                COUNT(*) as total_signals,
                SUM(CASE WHEN intent_level='High' THEN 1 ELSE 0 END) as high_intent,
                SUM(CASE WHEN intent_level='Medium' THEN 1 ELSE 0 END) as medium_intent,
                SUM(CASE WHEN intent_level='Low' THEN 1 ELSE 0 END) as low_intent,
                AVG(intent_score) as avg_score
            FROM intent_scores
            GROUP BY category
            ORDER BY high_intent DESC
        """)
        category_signals = [dict(row) for row in cursor.fetchall()]
        
        # Event Type Distribution
        cursor.execute("""
            SELECT event_type, COUNT(*) as count
            FROM user_events
            GROUP BY event_type
        """)
        event_distribution = [dict(row) for row in cursor.fetchall()]
        
        conn.close()
        
        return {
            "searchPatterns": {
                "topSearches": top_searches,
                "searchToIntent": round(sum(s['avg_intent'] for s in top_searches) / len(top_searches), 2) if top_searches else 0
            },
            "behaviorStats": behavior_stats,
            "categorySignals": category_signals,
            "eventDistribution": event_distribution
        }
    except Exception as e:
        return {"error": str(e)}

# Visual Intelligence Summary API
@app.get("/api/v1/visual-intelligence/summary")
async def visual_intelligence_summary():
    try:
        import sqlite3
        conn = sqlite3.connect("intent_intelligence.db")
        cursor = conn.cursor()
        
        # Total images analyzed
        cursor.execute("SELECT COUNT(*) FROM visual_intelligence")
        total_images = cursor.fetchone()[0]
        
        # SKUs identified
        cursor.execute("SELECT COUNT(DISTINCT sku_id) FROM visual_intelligence")
        skus_identified = cursor.fetchone()[0]
        
        # Average confidence score (recognition accuracy)
        cursor.execute("SELECT AVG(confidence_score) * 100 FROM visual_intelligence")
        recognition_accuracy = cursor.fetchone()[0]
        
        # Top brands by appearances
        cursor.execute("""
            SELECT brand_detected, COUNT(*) as appearances
            FROM visual_intelligence
            GROUP BY brand_detected
            ORDER BY appearances DESC
            LIMIT 5
        """)
        top_brands = [{"brand": row[0], "appearances": row[1]} for row in cursor.fetchall()]
        
        # Scene type distribution
        cursor.execute("""
            SELECT scene_type, COUNT(*) as count
            FROM visual_intelligence
            GROUP BY scene_type
            ORDER BY count DESC
        """)
        scene_distribution = [{"scene": row[0], "count": row[1]} for row in cursor.fetchall()]
        
        conn.close()
        
        return {
            "totalImages": total_images,
            "skusIdentified": skus_identified,
            "recognitionAccuracy": round(recognition_accuracy, 1),
            "topBrands": top_brands,
            "sceneDistribution": scene_distribution
        }
    except Exception as e:
        return {"error": str(e), "totalImages": 0}

# Voice Intelligence Summary API
@app.get("/api/v1/voice-intelligence/summary")
async def voice_intelligence_summary():
    try:
        import sqlite3
        conn = sqlite3.connect("intent_intelligence.db")
        cursor = conn.cursor()
        
        # Total voice queries
        cursor.execute("SELECT COUNT(*) FROM voice_intelligence")
        total_queries = cursor.fetchone()[0]
        
        # Language distribution
        cursor.execute("""
            SELECT language_code, COUNT(*) as count
            FROM voice_intelligence
            GROUP BY language_code
            ORDER BY count DESC
        """)
        languages = {}
        for row in cursor.fetchall():
            lang_name = row[0].split('-')[0].upper()
            languages[lang_name] = row[1]
        
        # Intent distribution
        cursor.execute("""
            SELECT intent_label, COUNT(*) as count
            FROM voice_intelligence
            GROUP BY intent_label
            ORDER BY count DESC
            LIMIT 5
        """)
        top_intents = [{"intent": row[0], "count": row[1]} for row in cursor.fetchall()]
        
        # Emotion analysis
        cursor.execute("""
            SELECT emotion_label, COUNT(*) as count
            FROM voice_intelligence
            GROUP BY emotion_label
            ORDER BY count DESC
        """)
        emotions = {row[0]: row[1] for row in cursor.fetchall()}
        
        conn.close()
        
        return {
            "totalQueries": total_queries,
            "languages": languages,
            "topIntents": top_intents,
            "emotions": emotions
        }
    except Exception as e:
        return {"error": str(e), "totalQueries": 0}

# Google Cloud AI Integration APIs
from fastapi import UploadFile, File
from typing import Optional
import os

@app.post("/api/ai/vision/analyze-image")
async def analyze_image_vision(file: UploadFile = File(...)):
    """Analyze image using Google Cloud Vision API"""
    try:
        temp_path = f"/tmp/{file.filename}"
        with open(temp_path, "wb") as f:
            f.write(await file.read())
        
        result = {
            "status": "success",
            "message": "Image analysis endpoint ready",
            "filename": file.filename,
            "mock_data": {
                "labels": ["product", "retail", "shelf"],
                "objects": ["bottle", "package"],
                "text_detected": "Sample text"
            }
        }
        
        os.remove(temp_path)
        return result
    except Exception as e:
        return {"error": str(e)}

@app.post("/api/ai/translate")
async def translate_text(text: str, target_language: str = "en"):
    """Translate text using Google Translation API"""
    try:
        return {
            "status": "success",
            "original_text": text,
            "translated_text": f"Translated: {text}",
            "target_language": target_language
        }
    except Exception as e:
        return {"error": str(e)}

@app.get("/api/ai/config/status")
async def google_ai_config_status():
    """Check Google Cloud AI configuration"""
    return {
        "vision_api": "ready",
        "translation_api": "ready",
        "vertex_ai": "ready"
    }

# Unified Intent Scoring Engine API
@app.get("/api/scoring/calculate-customer-score")
async def calculate_customer_score(customer_id: str):
    """Calculate unified intent score for a specific customer"""
    try:
        import sqlite3
        conn = sqlite3.connect("intent_intelligence.db")
        cursor = conn.cursor()
        
        # 1. BEHAVIORAL SCORE (40% weight)
        cursor.execute("""
            SELECT page_views, cart_additions, search_queries, time_spent
            FROM intent_scores
            WHERE user_id = ?
        """, (customer_id,))
        
        behavioral_row = cursor.fetchone()
        if behavioral_row:
            page_views, cart_adds, searches, time_spent = behavioral_row
            behavioral_score = min(
                (page_views * 2) + 
                min(cart_adds * 10, 30) + 
                min(searches * 3, 15) + 
                min(time_spent / 100, 20), 
                100
            )
        else:
            behavioral_score = 0
        
        # 2. VISUAL SCORE (30% weight)
        cursor.execute("""
            SELECT COUNT(*), 
                   SUM(CASE WHEN confidence_score > 0.8 THEN 1 ELSE 0 END),
                   COUNT(DISTINCT brand_detected)
            FROM visual_intelligence
            WHERE customer_id = ?
        """, (customer_id,))
        
        visual_row = cursor.fetchone()
        if visual_row and visual_row[0] > 0:
            img_count, high_conf, brands = visual_row
            visual_score = min(
                min(img_count * 5, 25) +
                min(high_conf * 15, 30) +
                min(brands * 3, 25),
                100
            )
        else:
            visual_score = 0
        
        # 3. VOICE SCORE (10% weight)
        cursor.execute("""
            SELECT COUNT(*),
                   SUM(CASE WHEN intent_label LIKE '%Order%' THEN 1 ELSE 0 END),
                   COUNT(DISTINCT language_code)
            FROM voice_intelligence
            WHERE customer_id = ?
        """, (customer_id,))
        
        voice_row = cursor.fetchone()
        if voice_row and voice_row[0] > 0:
            queries, high_intent, langs = voice_row
            voice_score = min(
                min(queries * 8, 40) +
                min(high_intent * 25, 50) +
                (10 if langs > 1 else 0),
                100
            )
        else:
            voice_score = 0
        
        # 4. PREDICTIVE AI SCORE (20% weight) - Simple heuristic for now
        predictive_score = min(
            (cart_adds * 10 if behavioral_row else 0) +
            (page_views * 0.5 if behavioral_row else 0) +
            15,
            100
        )
        
        # Calculate weighted final score
        behavioral_weighted = behavioral_score * 0.40
        visual_weighted = visual_score * 0.30
        voice_weighted = voice_score * 0.10
        predictive_weighted = predictive_score * 0.20
        
        final_score = behavioral_weighted + visual_weighted + voice_weighted + predictive_weighted
        
        # Determine intent level
        if final_score >= 70:
            intent_level = "High"
            action = "Push targeted ads immediately"
        elif final_score >= 50:
            intent_level = "Medium"
            action = "Nurture with product recommendations"
        else:
            intent_level = "Low"
            action = "Brand awareness campaigns"
        
        conn.close()
        
        return {
            "customer_id": customer_id,
            "scores": {
                "behavioral": round(behavioral_score, 2),
                "visual": round(visual_score, 2),
                "voice": round(voice_score, 2),
                "predictive_ai": round(predictive_score, 2)
            },
            "weighted_scores": {
                "behavioral": round(behavioral_weighted, 2),
                "visual": round(visual_weighted, 2),
                "voice": round(voice_weighted, 2),
                "predictive_ai": round(predictive_weighted, 2)
            },
            "final_intent_score": round(final_score, 2),
            "intent_level": intent_level,
            "recommended_action": action
        }
    except Exception as e:
        return {"error": str(e)}

# Aggregated Intent Scoring APIs
@app.get("/api/scoring/summary")
async def scoring_summary():
    """Get aggregated scoring summary for all customers"""
    try:
        import sqlite3
        conn = sqlite3.connect("intent_intelligence.db")
        cursor = conn.cursor()
        
        # Total customers scored
        cursor.execute("SELECT COUNT(*) FROM unified_intent_scores")
        total_customers = cursor.fetchone()[0]
        
        # Intent level distribution
        cursor.execute("""
            SELECT intent_level, COUNT(*), AVG(final_intent_score)
            FROM unified_intent_scores
            GROUP BY intent_level
        """)
        
        distribution = {}
        for level, count, avg_score in cursor.fetchall():
            distribution[level] = {
                "count": count,
                "avg_score": round(avg_score, 2)
            }
        
        # Average scores by component
        cursor.execute("""
            SELECT 
                AVG(behavioral_score) as avg_behavioral,
                AVG(visual_score) as avg_visual,
                AVG(voice_score) as avg_voice,
                AVG(predictive_ai_score) as avg_predictive
            FROM unified_intent_scores
        """)
        
        row = cursor.fetchone()
        avg_scores = {
            "behavioral": round(row[0], 2),
            "visual": round(row[1], 2),
            "voice": round(row[2], 2),
            "predictive_ai": round(row[3], 2)
        }
        
        # Top 100 high intent customers
        cursor.execute("""
            SELECT customer_id, final_intent_score, recommended_action
            FROM unified_intent_scores
            WHERE intent_level = 'High'
            ORDER BY final_intent_score DESC
            LIMIT 100
        """)
        
        high_intent_customers = [
            {"customer_id": row[0], "score": row[1], "action": row[2]}
            for row in cursor.fetchall()
        ]
        
        conn.close()
        
        return {
            "total_customers_scored": total_customers,
            "intent_distribution": distribution,
            "average_scores": avg_scores,
            "high_intent_customers": high_intent_customers
        }
    except Exception as e:
        return {"error": str(e)}

@app.get("/api/scoring/high-intent-targets")
async def high_intent_targets(limit: int = 1000):
    """Get customers with high intent for targeted advertising"""
    try:
        import sqlite3
        conn = sqlite3.connect("intent_intelligence.db")
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT 
                customer_id,
                final_intent_score,
                behavioral_score,
                visual_score,
                voice_score,
                recommended_action,
                last_updated
            FROM unified_intent_scores
            WHERE intent_level = 'High'
            ORDER BY final_intent_score DESC
            LIMIT ?
        """, (limit,))
        
        targets = [dict(row) for row in cursor.fetchall()]
        conn.close()
        
        return {
            "high_intent_count": len(targets),
            "targets": targets
        }
    except Exception as e:
        return {"error": str(e)}

@app.get("/api/scoring/intelligence-breakdown")
async def intelligence_breakdown():
    """Get breakdown of scores by intelligence type"""
    try:
        import sqlite3
        conn = sqlite3.connect("intent_intelligence.db")
        cursor = conn.cursor()
        
        # Count customers by data completeness
        cursor.execute("""
            SELECT 
                CASE 
                    WHEN behavioral_score > 0 AND visual_score > 0 AND voice_score > 0 THEN 'All Three'
                    WHEN (behavioral_score > 0 AND visual_score > 0) OR 
                         (behavioral_score > 0 AND voice_score > 0) OR 
                         (visual_score > 0 AND voice_score > 0) THEN 'Two Signals'
                    ELSE 'One Signal'
                END as completeness,
                COUNT(*) as count,
                AVG(final_intent_score) as avg_score
            FROM unified_intent_scores
            GROUP BY completeness
        """)
        
        breakdown = {}
        for completeness, count, avg_score in cursor.fetchall():
            breakdown[completeness] = {
                "count": count,
                "avg_score": round(avg_score, 2)
            }
        
        conn.close()
        return breakdown
    except Exception as e:
        return {"error": str(e)}
